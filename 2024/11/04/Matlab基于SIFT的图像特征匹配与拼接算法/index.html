<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Matlab基于SIFT的图像特征匹配与拼接算法 | RichLuv Studio</title><meta name="author" content="Clemenza"><meta name="copyright" content="Clemenza"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在Matlab上实现于SIFT的图像特征匹配与拼接算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Matlab基于SIFT的图像特征匹配与拼接算法">
<meta property="og:url" content="http://example.com/2024/11/04/Matlab%E5%9F%BA%E4%BA%8ESIFT%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8B%BC%E6%8E%A5%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="RichLuv Studio">
<meta property="og:description" content="在Matlab上实现于SIFT的图像特征匹配与拼接算法">
<meta property="og:locale">
<meta property="og:image" content="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg">
<meta property="article:published_time" content="2024-11-04T11:53:10.481Z">
<meta property="article:modified_time" content="2024-11-05T01:54:40.959Z">
<meta property="article:author" content="Clemenza">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="图像处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/11/04/Matlab%E5%9F%BA%E4%BA%8ESIFT%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8B%BC%E6%8E%A5%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Clemenza","link":"Link: ","source":"Source: RichLuv Studio","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Matlab基于SIFT的图像特征匹配与拼接算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-05 09:54:40'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/ccs/loading-bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/sza.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/touxiang1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 数字影像</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 标签归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 抖音</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 小红书</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">RichLuv Studio</span></a><a class="nav-page-title" href="/"><span class="site-name">Matlab基于SIFT的图像特征匹配与拼接算法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 数字影像</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 标签归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 抖音</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 小红书</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Matlab基于SIFT的图像特征匹配与拼接算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-04T11:53:10.481Z" title="Created 2024-11-04 19:53:10">2024-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-05T01:54:40.959Z" title="Updated 2024-11-05 09:54:40">2024-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>SIFT算法作为图像局部特征的里程碑式发明被广泛应用于各个领域，David Lowe的思想简单却深邃。网上能够直接在Matlab里面使用的算法很少，于是在这里简单介绍一下原理，然后实战。总的demo文件放在最后。</p>
<h3 id="SIFT算法简介"><a href="#SIFT算法简介" class="headerlink" title="SIFT算法简介"></a>SIFT算法简介</h3><p>**<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=1&q=%E5%B0%BA%E5%BA%A6%E4%B8%8D%E5%8F%98%E7%89%B9%E5%BE%81%E8%BD%AC%E6%8D%A2&zhida_source=entity">尺度不变特征转换</a>(SIFT, Scale Invariant Feature Transform)**是图像处理领域中的一种局部特征描述算法。是由David G. Lowe教授在1999年（《Object Recognition from Local Scale-Invariant Features》）提出的高效区域检测算法，在2004年（《Distinctive Image Features from Scale-Invariant Key points》）得以完善。该方法于1999年由加拿大教授David G.Lowe提出，申请了专利，其专利属于英属哥伦比亚大学. SIFT专利在2020年3月17日之后到期，现在只需更新cv版本即可免费使用。</p>
<p>SIFT算法不仅只有<strong>尺度不变性</strong>，当旋转图像，改变图像亮度，移动拍摄位置时，仍可得到较好的检测效果。其实，在我们生活中，SIFT算法还是有所应用的，比如，我们手机上的全景拍摄，当我们拿着手机旋转拍摄时，就可以得到一幅全景图，大家想过没有，手机摄像头的视角是确定的，为什么通过旋转拍摄时，角度就变大了呢？其实角度并没有变化，只是我们在旋转拍摄时，拍摄了很多的图像，这些图像相邻之间有重叠部分，把这些图像合在一起，去除重叠部分，就可以得到一幅全景图。</p>
<p>SIFT算法网址：</p>
<p><a href="https://link.zhihu.com/?target=https://www.cs.ubc.ca/~lowe/keypoints/">https://www.cs.ubc.ca/<del>lowe&#x2F;keypoints&#x2F;www.cs.ubc.ca/</del>lowe&#x2F;keypoints&#x2F;</a></p>
<p>这是David G. Lowe教授的SIFT算法Demo，在后面实战中是根据这个<strong>改进</strong>的。</p>
<p><img src="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg" alt="img"></p>
<center>图1 SIFT demo下载网站（点击红框处下载）</center>

<h3 id="SIFT算法原理"><a href="#SIFT算法原理" class="headerlink" title="SIFT算法原理"></a><strong>SIFT算法原理</strong></h3><p>David lowe在2004年的文章 Distinctive Image Features from Scale-Invariant Keypoints 中总结了SIFT特征检测算法的四个主要步骤：</p>
<p><strong>a.</strong> <strong>尺度空间的极值检测(Scale-space extrema detection)</strong></p>
<p>检测尺度空间极值就是搜索所有尺度上的图像位置，通过高斯微分函数来识别对于尺度和旋转不变的兴趣点。其主要步骤可以分为建立<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=1&q=%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94&zhida_source=entity">高斯金字塔</a>、生成<strong>DOG高斯差分金字塔</strong>和<strong>DOG局部极值点检测</strong>。</p>
<p>图2右侧是高斯金字塔中同一Octave的不同卷积核卷积图像的差分得到的图像集。因为是差分得到的图像，故每个Octave相较于高斯金字塔中Octave数量上会减少一张。因为差分得到的图像集也是垂直方向分布，形状类似于金字塔，故被称作 “<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=2&q=%E9%AB%98%E6%96%AF%E5%B7%AE%E5%88%86%E9%87%91%E5%AD%97%E5%A1%94&zhida_source=entity">高斯差分金字塔</a>”。</p>
<p><img src="https://pica.zhimg.com/v2-64eaaa30fb86a404bda9f81ce689c8fe_1440w.jpg" alt="img"></p>
<center>图2 高斯差分图</center>

<p>特征点是由DOG空间的局部极值点组成的。为了寻找DOG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小<strong>。SIFT算法选择高斯差分金字塔中的极值点作为代表图像特征的关键点。</strong>需要注意的是：这里所说的极值点不仅仅是在一幅图像中像素值为极值的点，而是该点像素值对于与其同图像的八邻域和上一张图像相同位置点以及八邻域、下一张图像相同位置点以及八邻域共计26个像素值为局部极值。（如下图所示，中心黑色叉点为中心点，其将与周围共计26个绿色标记点比较确定是否为极值点）</p>
<p><img src="https://pic1.zhimg.com/v2-7d0d1a3be1760f092b16e102c7a876c6_1440w.jpg" alt="img"></p>
<center>图3 局部极值点检测</center>

<p><strong>b.</strong> <strong>关键点精确定位(Keypoint localization)</strong></p>
<p>为提高图像特征点对噪声的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=1&q=%E9%B2%81%E6%A3%92%E6%80%A7&zhida_source=entity">鲁棒性</a>，SIFT算法的通常做法是对比测试和边缘测试。</p>
<p>对比测试是指为解决对比度较低的极值点，对所有极值点进行二阶泰勒展开（second-order Taylor expansion）。如果结果值小于0.03，则剔除该关键点。边缘测试是指使用二阶Hessian矩阵来识别具有高边缘度但对少量噪声没有鲁棒性的关键点。</p>
<p><strong>c.</strong> <strong>关键点主方向分配(Orientation assignment)</strong></p>
<p>在建立高斯差分金字塔以选取图像特征点时，算法考虑了关键点的尺度不变性。而对于图像特征而言，与尺度不变性同等重要的还有旋转不变性。为使算法定义的图像特征具有旋转不变性，我们需要在定位特征点后对特征点定义 “主方向”，该“主方向”生成特征点周围的局部区域的梯度方向基准，使图像在旋转后仍能与旋转前保持相同的特征描述。</p>
<p>算法将关键点指定大小领域中的所有点计算梯度方向与赋值，并统计所有梯度方向对应的赋值和，作关键点周围i邻域梯度方向直方图。</p>
<p>图4右侧梯度方向直方图为简化版本（只有8个bin，实际操作时算法会统计从0到360°步长为10°的共计36个梯度方向的幅值和，共有36个bin）。梯度方向直方图中最高的bin对应的方向即定义为该关键点的主方向，若存在任一方向的幅值大于主方向幅值的80%，则将其作为辅方向。</p>
<p>获得图像关键点主方向后，每个关键点有三个信息(x,y,σ,θ)：位置（x,y)、尺度σ、方向θ。</p>
<p><img src="https://pic3.zhimg.com/v2-e58eca6746289f441b3238012e5cc602_1440w.jpg" alt="img"></p>
<center>图4 局部极值点检测</center>

<p><strong>d.</strong> <strong>关键点描述子的生成(Keypoint descriptor)</strong></p>
<p>得到特征点二维位置、尺度位置、主方向的具体信息后，算法需要解决的最后一个问题就是生成关键点信息的描述子，即用一个向量描述图像中的特征点信息。</p>
<p>算法将特征点周围的1616邻域分为4个88的区域，再将88的区域划为22区域，即每个小区域为44的范围。统计每个44区域的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=4&q=%E6%A2%AF%E5%BA%A6%E6%96%B9%E5%90%91%E7%9B%B4%E6%96%B9%E5%9B%BE&zhida_source=entity">梯度方向直方图</a>（直方图为8个bin），故共计448&#x3D;128个bin（每个1616邻域有44个44邻域，每个44邻域有8个bin）。对应生成128维向量（值为梯度方向的幅值）。该128维向量即该点的特征描述子。</p>
<p><img src="https://pica.zhimg.com/v2-71d6348e3ff8637ccf21d7886433f53e_1440w.jpg" alt="img"></p>
<center>图5 关键点描述子的生成</center>

<h3 id="SIFT代码实战"><a href="#SIFT代码实战" class="headerlink" title="SIFT代码实战"></a><strong>SIFT代码实战</strong></h3><p>*<strong>1-sift.m 检测特征点(返回图像的SIFT特征点)+构建特征点描述子*</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% [descriptors, locs] = sift(img)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% This function returns IMAGE&#x27;s SIFT keypoints.</span></span><br><span class="line"><span class="comment">%   Input parameters:</span></span><br><span class="line"><span class="comment">%     img: the image.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Returned:</span></span><br><span class="line"><span class="comment">%     descriptors: a K-by-128 matrix, where each row gives an invariant</span></span><br><span class="line"><span class="comment">%         descriptor for one of the K keypoints.  The descriptor is a vector</span></span><br><span class="line"><span class="comment">%         of 128 values normalized to unit length.</span></span><br><span class="line"><span class="comment">%     locs: K-by-4 matrix, in which each row has the 4 values for a</span></span><br><span class="line"><span class="comment">%         keypoint location (row, column, scale, orientation).  The </span></span><br><span class="line"><span class="comment">%         orientation is in the range [-PI, PI] radians.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Credits: Thanks for initial version of this program to D. Alvaro and </span></span><br><span class="line"><span class="comment">%          J.J. Guerrero, Universidad de Zaragoza (modified by D. Lowe)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[descriptors, locs]</span> = <span class="title">sift</span><span class="params">(img)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% If you have the Image Processing Toolbox, you can uncomment the following</span></span><br><span class="line"><span class="comment">%   lines to allow input of color images, which will be converted to grayscale.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>)</span><br><span class="line">   img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[rows, cols] = <span class="built_in">size</span>(img); </span><br><span class="line"></span><br><span class="line"><span class="comment">% Convert into PGM imagefile, readable by &quot;keypoints&quot; executable</span></span><br><span class="line">f = fopen(<span class="string">&#x27;tmp.pgm&#x27;</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> f == <span class="number">-1</span></span><br><span class="line">    error(<span class="string">&#x27;Could not create file tmp.pgm.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(f, <span class="string">&#x27;P5\n%d\n%d\n255\n&#x27;</span>, cols, rows);</span><br><span class="line">fwrite(f, img&#x27;, <span class="string">&#x27;uint8&#x27;</span>);</span><br><span class="line">fclose(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Call keypoints executable</span></span><br><span class="line"><span class="keyword">if</span> isunix</span><br><span class="line">    command = <span class="string">&#x27;./sift &#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command = <span class="string">&#x27;siftWin32 &#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">command = [command <span class="string">&#x27; &lt;tmp.pgm &gt;tmp.key&#x27;</span>];</span><br><span class="line">system(sprintf(command));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Open tmp.key and check its header</span></span><br><span class="line">g = fopen(<span class="string">&#x27;tmp.key&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> g == <span class="number">-1</span></span><br><span class="line">    error(<span class="string">&#x27;Could not open file tmp.key.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[header, count] = fscanf(g, <span class="string">&#x27;%d %d&#x27;</span>, [<span class="number">1</span> <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> count ~= <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;Invalid keypoint file beginning.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">num = header(<span class="number">1</span>);</span><br><span class="line">len = header(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> len ~= <span class="number">128</span></span><br><span class="line">    error(<span class="string">&#x27;Keypoint descriptor length invalid (should be 128).&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Creates the two output matrices (use known size for efficiency)</span></span><br><span class="line">locs = double(<span class="built_in">zeros</span>(num, <span class="number">4</span>));</span><br><span class="line">descriptors = double(<span class="built_in">zeros</span>(num, <span class="number">128</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Parse tmp.key</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num</span><br><span class="line">    [vector, count] = fscanf(g, <span class="string">&#x27;%f %f %f %f&#x27;</span>, [<span class="number">1</span> <span class="number">4</span>]); <span class="comment">%row col scale ori</span></span><br><span class="line">    <span class="keyword">if</span> count ~= <span class="number">4</span></span><br><span class="line">        error(<span class="string">&#x27;Invalid keypoint file format&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    locs(<span class="built_in">i</span>, :) = vector(<span class="number">1</span>, :);</span><br><span class="line">    </span><br><span class="line">    [descrip, count] = fscanf(g, <span class="string">&#x27;%d&#x27;</span>, [<span class="number">1</span> len]);</span><br><span class="line">    <span class="keyword">if</span> (count ~= <span class="number">128</span>)</span><br><span class="line">        error(<span class="string">&#x27;Invalid keypoint file value.&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% Normalize each input vector to unit length</span></span><br><span class="line">    descrip = descrip / <span class="built_in">sqrt</span>(sum(descrip.^<span class="number">2</span>));</span><br><span class="line">    descriptors(<span class="built_in">i</span>, :) = descrip(<span class="number">1</span>, :);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%delete tmp.key</span></span><br><span class="line">fclose(g);</span><br></pre></td></tr></table></figure>

<p>*<strong>2-siftMatch.m 读入两幅图像，寻找它们的SIFT特征，显示相互匹配的特征点的连线*</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% [matchLoc1 matchLoc2] = siftMatch(img1, img2)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% This function reads two images, finds their SIFT features, and</span></span><br><span class="line"><span class="comment">%   displays lines connecting the matched keypoints.  A match is accepted</span></span><br><span class="line"><span class="comment">%   only if its distance is less than distRatio times the distance to the</span></span><br><span class="line"><span class="comment">%   second closest match.</span></span><br><span class="line"><span class="comment">% It returns the matched points of both images, matchLoc1 = [x1,y1;x2,y2;...]</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Example: match(&#x27;scene.pgm&#x27;,&#x27;book.pgm&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[matchLoc1 matchLoc2]</span> = <span class="title">siftMatch</span><span class="params">(img1, img2)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% load matchdata</span></span><br><span class="line"><span class="comment">% load img1data</span></span><br><span class="line"><span class="comment">% load img2data</span></span><br><span class="line"><span class="comment">%&#123;,</span></span><br><span class="line"><span class="comment">% Find SIFT keypoints for each image</span></span><br><span class="line">[des1, loc1] = sift(img1);</span><br><span class="line">[des2, loc2] = sift(img2);</span><br><span class="line"><span class="comment">% save img1data des1 loc1</span></span><br><span class="line"><span class="comment">% save img2data des2 loc2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% For efficiency in Matlab, it is cheaper to compute dot products between</span></span><br><span class="line"><span class="comment">%  unit vectors rather than Euclidean distances.  Note that the ratio of </span></span><br><span class="line"><span class="comment">%  angles (acos of dot products of unit vectors) is a close approximation</span></span><br><span class="line"><span class="comment">%  to the ratio of Euclidean distances for small angles.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% distRatio: Only keep matches in which the ratio of vector angles from the</span></span><br><span class="line"><span class="comment">%   nearest to second nearest neighbor is less than distRatio.</span></span><br><span class="line">distRatio = <span class="number">0.6</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">% For each descriptor in the first image, select its match to second image.</span></span><br><span class="line">des2t = des2&#x27;;                          <span class="comment">% Precompute matrix transpose</span></span><br><span class="line">matchTable = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(des1,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(des1,<span class="number">1</span>)</span><br><span class="line">   dotprods = des1(<span class="built_in">i</span>,:) * des2t;        <span class="comment">% Computes vector of dot products</span></span><br><span class="line">   [vals,indx] = <span class="built_in">sort</span>(<span class="built_in">acos</span>(dotprods));  <span class="comment">% Take inverse cosine and sort results</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">% Check if nearest neighbor has angle less than distRatio times 2nd.</span></span><br><span class="line">   <span class="keyword">if</span> (vals(<span class="number">1</span>) &lt; distRatio * vals(<span class="number">2</span>))</span><br><span class="line">      matchTable(<span class="built_in">i</span>) = indx(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      matchTable(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% save matchdata matchTable</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Create a new image showing the two images side by side.</span></span><br><span class="line">img3 = appendimages(img1,img2);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Show a figure with lines joining the accepted matches.</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>, [<span class="number">100</span> <span class="number">100</span> <span class="built_in">size</span>(img3,<span class="number">2</span>) <span class="built_in">size</span>(img3,<span class="number">1</span>)]);</span><br><span class="line">colormap(<span class="string">&#x27;gray&#x27;</span>);</span><br><span class="line">imagesc(img3);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">cols1 = <span class="built_in">size</span>(img1,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(des1,<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> (matchTable(<span class="built_in">i</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    line([loc1(<span class="built_in">i</span>,<span class="number">2</span>) loc2(matchTable(<span class="built_in">i</span>),<span class="number">2</span>)+cols1], ...</span><br><span class="line">         [loc1(<span class="built_in">i</span>,<span class="number">1</span>) loc2(matchTable(<span class="built_in">i</span>),<span class="number">1</span>)], <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">num = sum(matchTable &gt; <span class="number">0</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;Found %d matches.\n&#x27;</span>, num);</span><br><span class="line"></span><br><span class="line">idx1 = <span class="built_in">find</span>(matchTable);</span><br><span class="line">idx2 = matchTable(idx1);</span><br><span class="line">x1 = loc1(idx1,<span class="number">2</span>);</span><br><span class="line">x2 = loc2(idx2,<span class="number">2</span>);</span><br><span class="line">y1 = loc1(idx1,<span class="number">1</span>);</span><br><span class="line">y2 = loc2(idx2,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">matchLoc1 = [x1,y1];</span><br><span class="line">matchLoc2 = [x2,y2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>*<strong>3-ransac1.m RANSAC算法进行<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=1&q=%E5%9B%BE%E5%83%8F%E9%85%8D%E5%87%86&zhida_source=entity">图像配准</a>*</strong></p>
<p>在进行两幅或多幅图像间的镶嵌及配准时，通常情况下都会有一个参考图像或者基准图像作为处理的标准。其中就需要建立原始图像到参考图像的变换模型，而模型参数的稳健估计就成了关键技术之一。在实际问题中，得到的数据往往并不是完全准确的，常常伴随着许多异常数据，于是问题的关键在于如何处理不符合实际模型的异常数据。</p>
<p><img src="https://pica.zhimg.com/v2-8e74180184ef20596a5209385fc6269e_1440w.jpg" alt="img"></p>
<center>图3 左图：包含很多局外点的数据集；右图：RANSAC找到的直线（局外点并不影响结果）</center>

<p>一个简单的例子是从一组观测数据中找出合适的2维直线。假设观测数据中包含局内点和局外点，其中局内点近似的被直线所通过，而局外点远离于直线。简单的最小二乘法不能找到适应于局内点的直线，原因是最小二乘法尽量去适应包括局外点在内的所有点。相反，RANSAC能得出一个仅仅用局内点计算出模型，并且概率还足够高。但是，RANSAC并不能保证结果一定正确，为了保证算法有足够高的合理概率，我们必须小心的选择算法的参数。</p>
<p>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[f inlierIdx]</span> = <span class="title">ransac1</span><span class="params">( x,y,ransacCoef,funcFindF,funcDist )</span></span></span><br><span class="line"><span class="comment">%[f inlierIdx] = ransac1( x,y,ransacCoef,funcFindF,funcDist )</span></span><br><span class="line"><span class="comment">%	Use RANdom SAmple Consensus to find a fit from X to Y.</span></span><br><span class="line"><span class="comment">%	X is M*n matrix including n points with dim M, Y is N*n;</span></span><br><span class="line"><span class="comment">%	The fit, f, and the indices of inliers, are returned.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%	RANSACCOEF is a struct with following fields:</span></span><br><span class="line"><span class="comment">%	minPtNum,iterNum,thDist,thInlrRatio</span></span><br><span class="line"><span class="comment">%	MINPTNUM is the minimum number of points with whom can we </span></span><br><span class="line"><span class="comment">%	find a fit. For line fitting, it&#x27;s 2. For homography, it&#x27;s 4.</span></span><br><span class="line"><span class="comment">%	ITERNUM is the number of iteration, THDIST is the inlier </span></span><br><span class="line"><span class="comment">%	distance threshold and ROUND(THINLRRATIO*n) is the inlier number threshold.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%	FUNCFINDF is a func handle, f1 = funcFindF(x1,y1)</span></span><br><span class="line"><span class="comment">%	x1 is M*n1 and y1 is N*n1, n1 &gt;= ransacCoef.minPtNum</span></span><br><span class="line"><span class="comment">%	f1 can be of any type.</span></span><br><span class="line"><span class="comment">%	FUNCDIST is a func handle, d = funcDist(f,x1,y1)</span></span><br><span class="line"><span class="comment">%	It uses f returned by FUNCFINDF, and return the distance</span></span><br><span class="line"><span class="comment">%	between f and the points, d is 1*n1.</span></span><br><span class="line"><span class="comment">%	For line fitting, it should calculate the dist between the line and the</span></span><br><span class="line"><span class="comment">%	points [x1;y1]; for homography, it should project x1 to y2 then</span></span><br><span class="line"><span class="comment">%	calculate the dist between y1 and y2.</span></span><br><span class="line">minPtNum = ransacCoef.minPtNum;</span><br><span class="line">iterNum = ransacCoef.iterNum;</span><br><span class="line">thInlrRatio = ransacCoef.thInlrRatio;</span><br><span class="line">thDist = ransacCoef.thDist;</span><br><span class="line">ptNum = <span class="built_in">size</span>(x,<span class="number">2</span>);</span><br><span class="line">thInlr = <span class="built_in">round</span>(thInlrRatio*ptNum);</span><br><span class="line"></span><br><span class="line">inlrNum = <span class="built_in">zeros</span>(<span class="number">1</span>,iterNum);</span><br><span class="line">fLib = cell(<span class="number">1</span>,iterNum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p = <span class="number">1</span>:iterNum</span><br><span class="line">	<span class="comment">% 1. fit using  random points</span></span><br><span class="line">	sampleIdx = randIndex(ptNum,minPtNum);</span><br><span class="line">	f1 = funcFindF(x(:,sampleIdx),y(:,sampleIdx));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 2. count the inliers, if more than thInlr, refit; else iterate</span></span><br><span class="line">	dist = funcDist(f1,x,y);</span><br><span class="line">	inlier1 = <span class="built_in">find</span>(dist &lt; thDist);</span><br><span class="line">	inlrNum(p) = <span class="built_in">length</span>(inlier1);</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">length</span>(inlier1) &lt; thInlr, <span class="keyword">continue</span>; <span class="keyword">end</span></span><br><span class="line">	fLib&#123;p&#125; = funcFindF(x(:,inlier1),y(:,inlier1));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 3. choose the coef with the most inliers</span></span><br><span class="line">[~,idx] = <span class="built_in">max</span>(inlrNum);</span><br><span class="line">f = fLib&#123;idx&#125;;</span><br><span class="line">dist = funcDist(f,x,y);</span><br><span class="line">inlierIdx = <span class="built_in">find</span>(dist &lt; thDist);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>*<strong>4-solveHomo.m 图像配准—单应矩阵求解*</strong></p>
<p>为了实现影像匹配，在提取特征点后，变换矩阵H的求解是图像配准的核心。主要用到RANSAC函数迭代精炼H变换矩阵。</p>
<p>函数solveHomo和函数calcDist在RANSAC函数中被反复调用，最终得到最优点及对应的单应矩阵H。</p>
<p>在实际计算中仍把单应性矩阵作为9个元素来处理，这是由于<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=1&q=%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87&zhida_source=entity">齐次坐标</a>变换之后仍需归一化得到实际坐标，因此对应点组数n至少需要5个，才能保证方程组有解。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">H</span> = <span class="title">solveHomo</span><span class="params">(pts1,pts2)</span></span></span><br><span class="line"><span class="comment">%	H is 3*3, H*[pts1(:,i);1] ~ [pts2(:,i);1], H(3,3) = 1</span></span><br><span class="line"><span class="comment">%	the solving method see &quot;projective-Seitz-UWCSE.ppt&quot;</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(pts1,<span class="number">2</span>);</span><br><span class="line">A = <span class="built_in">zeros</span>(<span class="number">2</span>*n,<span class="number">9</span>);</span><br><span class="line">A(<span class="number">1</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">1</span>:<span class="number">2</span>) = pts1&#x27;;</span><br><span class="line">A(<span class="number">1</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">3</span>) = <span class="number">1</span>;</span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">4</span>:<span class="number">5</span>) = pts1&#x27;;</span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line">x1 = pts1(<span class="number">1</span>,:)&#x27;;</span><br><span class="line">y1 = pts1(<span class="number">2</span>,:)&#x27;;</span><br><span class="line">x2 = pts2(<span class="number">1</span>,:)&#x27;;</span><br><span class="line">y2 = pts2(<span class="number">2</span>,:)&#x27;;</span><br><span class="line">A(<span class="number">1</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">7</span>) = -x2.*x1;</span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">7</span>) = -y2.*x1;</span><br><span class="line">A(<span class="number">1</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">8</span>) = -x2.*y1;</span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">8</span>) = -y2.*y1;</span><br><span class="line">A(<span class="number">1</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">9</span>) = -x2;</span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">2</span>*n,<span class="number">9</span>) = -y2;</span><br><span class="line"></span><br><span class="line">[evec,~] = eig(A&#x27;*A);</span><br><span class="line">H = <span class="built_in">reshape</span>(evec(:,<span class="number">1</span>),[<span class="number">3</span>,<span class="number">3</span>])&#x27;;</span><br><span class="line">H = H/H(<span class="keyword">end</span>); <span class="comment">% make H(3,3) = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>*<strong>5-imMosaic.m 图像合成*</strong></p>
<p>由于普通的相机在拍摄照片时会自动选取曝光参数，这会使输入图像之间存在亮度差异，导致拼接后图像缝合线两端出现明显的明暗变化。因此，在融合过程中需要对缝合线进行处理，以平滑两幅图像两端的明暗差异。进行图像拼接缝合线的方法有很多种，如颜色插值和多分辨率样条技术等，本次研究使用了快速简单的加权平滑算法处理拼接缝问题。</p>
<p>图像重叠区域中像素点的灰度值Pixel由两幅图像对应点的灰度值Pixel_L和Pixel_R加权均得到，即Pixel&#x3D;k*Pixel_L+(1-k)*Pixel_R。其中k是可调因子。通常情况下，0&lt;k&lt;1，即在重叠区域中，沿图像1向图像2的方向，k由1渐变为0，从而实现重叠区域的平滑拼接。为使图像重叠区域中的点与两幅图像建立更大的相关性，令k&#x3D;d1&#x2F;(d1+d2)，其中d1，d2分别表示重叠区域中的点到两幅图像重叠区域的左边界和右边界的距离，即用公式Pixel&#x3D;d1&#x2F;(d1+d2)*Pixel_L+d2&#x2F;(d1+d2)*Pixel_R，进行缝合线处理。</p>
<p>此部分主要包括两个部分：</p>
<p><strong>·</strong>拼接前对图像1的灰度值向图像2一次线性拟合；</p>
<p><strong>·</strong>匹配后的图像1和图像21进行拼接。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ imgout ]</span> = <span class="title">imMosaic</span><span class="params">( img1,img2,adjColor )</span></span></span><br><span class="line"><span class="comment">%[ imgout ] = imMosaic( img1,img2,adjColor )</span></span><br><span class="line"><span class="comment">%	img1 and img2 can (both) be rgb or gray, double or uint8.</span></span><br><span class="line"><span class="comment">%	If you have more than 2 images to do mosaic, call this function several</span></span><br><span class="line"><span class="comment">%	times.</span></span><br><span class="line"><span class="comment">%	If you set adjColor to 1, imMosaic will try to try to adjust the</span></span><br><span class="line"><span class="comment">%	color(for rgb) or grayscale(for gray image) of img1 linearly, so the 2 </span></span><br><span class="line"><span class="comment">%	images can join more naturally.</span></span><br><span class="line"><span class="comment">%	Yan Ke @ THUEE, 20110123, xjed09@gmail.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% use SIFT to find corresponding points</span></span><br><span class="line">[matchLoc1, matchLoc2] = siftMatch(img1, img2);</span><br><span class="line"></span><br><span class="line"><span class="comment">% use RANSAC to find homography matrix</span></span><br><span class="line">[H, corrPtIdx] = findHomography(matchLoc2&#x27;,matchLoc1&#x27;);</span><br><span class="line">H  <span class="comment">%#ok</span></span><br><span class="line">tform = maketform(<span class="string">&#x27;projective&#x27;</span>,H&#x27;);</span><br><span class="line">img21 = imtransform(img2,tform); <span class="comment">% reproject img2</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(img1)</span><br><span class="line"><span class="built_in">figure</span>,imshow(img21)</span><br><span class="line"></span><br><span class="line"><span class="comment">% adjust color or grayscale linearly, using corresponding infomation</span></span><br><span class="line">[M1, N1, dim] = <span class="built_in">size</span>(img1);</span><br><span class="line">[M2, N2, ~] = <span class="built_in">size</span>(img2);</span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&#x27;adjColor&#x27;</span>,<span class="string">&#x27;var&#x27;</span>) &amp;&amp; adjColor == <span class="number">1</span></span><br><span class="line">	radius = <span class="number">2</span>;</span><br><span class="line">	x1ctrl = matchLoc1(corrPtIdx,<span class="number">1</span>);</span><br><span class="line">	y1ctrl = matchLoc1(corrPtIdx,<span class="number">2</span>);</span><br><span class="line">	x2ctrl = matchLoc2(corrPtIdx,<span class="number">1</span>);</span><br><span class="line">	y2ctrl = matchLoc2(corrPtIdx,<span class="number">2</span>);</span><br><span class="line">	ctrlLen = <span class="built_in">length</span>(corrPtIdx);</span><br><span class="line">	s1 = <span class="built_in">zeros</span>(<span class="number">1</span>,ctrlLen);</span><br><span class="line">	s2 = <span class="built_in">zeros</span>(<span class="number">1</span>,ctrlLen);</span><br><span class="line">	<span class="keyword">for</span> color = <span class="number">1</span>:dim</span><br><span class="line">		<span class="keyword">for</span> p = <span class="number">1</span>:ctrlLen</span><br><span class="line">			left = <span class="built_in">round</span>(<span class="built_in">max</span>(<span class="number">1</span>,x1ctrl(p)-radius));</span><br><span class="line">			right = <span class="built_in">round</span>(<span class="built_in">min</span>(N1,left+radius+<span class="number">1</span>));</span><br><span class="line">			up = <span class="built_in">round</span>(<span class="built_in">max</span>(<span class="number">1</span>,y1ctrl(p)-radius));</span><br><span class="line">			down = <span class="built_in">round</span>(<span class="built_in">min</span>(M1,up+radius+<span class="number">1</span>));</span><br><span class="line">			s1(p) = sum(sum(img1(up:down,left:right,color))); <span class="comment">% ȡ���ܵ�ɫ��</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">for</span> p = <span class="number">1</span>:ctrlLen</span><br><span class="line">			left = <span class="built_in">round</span>(<span class="built_in">max</span>(<span class="number">1</span>,x2ctrl(p)-radius));</span><br><span class="line">			right = <span class="built_in">round</span>(<span class="built_in">min</span>(N2,left+radius+<span class="number">1</span>));</span><br><span class="line">			up = <span class="built_in">round</span>(<span class="built_in">max</span>(<span class="number">1</span>,y2ctrl(p)-radius));</span><br><span class="line">			down = <span class="built_in">round</span>(<span class="built_in">min</span>(M2,up+radius+<span class="number">1</span>));</span><br><span class="line">			s2(p) = sum(sum(img2(up:down,left:right,color)));</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		sc = (radius*<span class="number">2</span>+<span class="number">1</span>)^<span class="number">2</span>*ctrlLen;</span><br><span class="line">		adjcoef = polyfit(s1/sc,s2/sc,<span class="number">1</span>);</span><br><span class="line">		img1(:,:,color) = img1(:,:,color)*adjcoef(<span class="number">1</span>)+adjcoef(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% do the mosaic</span></span><br><span class="line">pt = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">pt(:,<span class="number">1</span>) = H*[<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line">pt(:,<span class="number">2</span>) = H*[N2;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line">pt(:,<span class="number">3</span>) = H*[N2;M2;<span class="number">1</span>];</span><br><span class="line">pt(:,<span class="number">4</span>) = H*[<span class="number">1</span>;M2;<span class="number">1</span>];</span><br><span class="line">x2 = pt(<span class="number">1</span>,:)./pt(<span class="number">3</span>,:);</span><br><span class="line">y2 = pt(<span class="number">2</span>,:)./pt(<span class="number">3</span>,:);</span><br><span class="line"></span><br><span class="line">up = <span class="built_in">round</span>(<span class="built_in">min</span>(y2));</span><br><span class="line">Yoffset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> up &lt;= <span class="number">0</span></span><br><span class="line">	Yoffset = -up+<span class="number">1</span>;</span><br><span class="line">	up = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">left = <span class="built_in">round</span>(<span class="built_in">min</span>(x2));</span><br><span class="line">Xoffset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> left&lt;=<span class="number">0</span></span><br><span class="line">	Xoffset = -left+<span class="number">1</span>;</span><br><span class="line">	left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[M3, N3 ,~] = <span class="built_in">size</span>(img21);</span><br><span class="line">imgout(up:up+M3<span class="number">-1</span>,left:left+N3<span class="number">-1</span>,:) = img21;</span><br><span class="line">	<span class="comment">% img1 is above img21</span></span><br><span class="line">imgout(Yoffset+<span class="number">1</span>:Yoffset+M1,Xoffset+<span class="number">1</span>:Xoffset+N1,:) = img1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>*<strong>6-findHomography.m 单应性矩阵计算函数*</strong></p>
<p>findHomography: 计算多个二维点对之间的最优单映射变换矩阵H(3行3列)，使用最小均方误差或RANSAC方法。函数功能：该函数能够找到并返回源平面和目标平面之间的转换矩阵H，以便于反向投影错误率达到最小。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[H corrPtIdx]</span> = <span class="title">findHomography</span><span class="params">(pts1,pts2)</span></span></span><br><span class="line"><span class="comment">% [H corrPtIdx] = findHomography(pts1,pts2)</span></span><br><span class="line"><span class="comment">%	Find the homography between two planes using a set of corresponding</span></span><br><span class="line"><span class="comment">%	points. PTS1 = [x1,x2,...;y1,y2,...]. RANSAC method is used.</span></span><br><span class="line"><span class="comment">%	corrPtIdx is the indices of inliers.</span></span><br><span class="line"></span><br><span class="line">coef.minPtNum = <span class="number">4</span>;</span><br><span class="line">coef.iterNum = <span class="number">30</span>;</span><br><span class="line">coef.thDist = <span class="number">4</span>;</span><br><span class="line">coef.thInlrRatio = <span class="number">.1</span>;</span><br><span class="line">[H corrPtIdx] = ransac1(pts1,pts2,coef,@solveHomo,@calcDist);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">calcDist</span><span class="params">(H,pts1,pts2)</span></span></span><br><span class="line"><span class="comment">%	Project PTS1 to PTS3 using H, then calcultate the distances between</span></span><br><span class="line"><span class="comment">%	PTS2 and PTS3</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(pts1,<span class="number">2</span>);</span><br><span class="line">pts3 = H*[pts1;<span class="built_in">ones</span>(<span class="number">1</span>,n)];</span><br><span class="line">pts3 = pts3(<span class="number">1</span>:<span class="number">2</span>,:)./<span class="built_in">repmat</span>(pts3(<span class="number">3</span>,:),<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">d = sum((pts2-pts3).^<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>*<strong>7-mosaicTest.m 主函数*</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">close all</span><br><span class="line">config;</span><br><span class="line"><span class="comment">% f = &#x27;a&#x27;;</span></span><br><span class="line">ext = <span class="string">&#x27;jpg&#x27;</span>;</span><br><span class="line">img1 = imread([<span class="string">&#x27;视图2.&#x27;</span> ext]);</span><br><span class="line">img2 = imread([<span class="string">&#x27;视图1.&#x27;</span> ext]);</span><br><span class="line"></span><br><span class="line">img0 = imMosaic(img2,img1,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(img0)</span><br><span class="line">imwrite(img0,[<span class="string">&#x27;mosaic_1.&#x27;</span> ext],ext)</span><br></pre></td></tr></table></figure>

<h3 id="图像拼接结果"><a href="#图像拼接结果" class="headerlink" title="图像拼接结果"></a>图像拼接结果</h3><p>两张原图：</p>
<p><img src="https://picx.zhimg.com/v2-b8c59c642cb55d882c0ba49162a30f0b_1440w.jpg" alt="img"></p>
<center>原图1</center>

<p><img src="https://pica.zhimg.com/v2-d28ad687306e5ff48b56da4ff9da82aa_1440w.jpg" alt="img"></p>
<center>原图2</center>

<p>两张图特征点匹配结果：</p>
<p><img src="https://pic2.zhimg.com/v2-0dd8b2038f38d00d26576373d3c52e31_1440w.jpg" alt="img"></p>
<center>两张图特征点匹配结果</center>

<p>拼接效果：</p>
<p><img src="https://pic1.zhimg.com/v2-438c6c9b278c8a2717224ac04b93ceb8_1440w.jpg" alt="img"></p>
<center>两张图的拼接效果</center>

<p>如果想对一系列的图片进行拼接，可以先对第一张和第二张进行拼接，得到一张拼接图，再与第三张图片进行拼接，依次类推。</p>
<p><strong>由于还需要一些其他文件</strong>，因此将整体的demo文件放在这里：</p>
<p>链接：<a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1D-CMz44Zgz174Q5xPrnlWw">https://pan.baidu.com/s/1D-CMz44Zgz174Q5xPrnlWw</a></p>
<p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239040753&content_type=Article&match_order=1&q=%E6%8F%90%E5%8F%96%E7%A0%81&zhida_source=entity">提取码</a>：sift</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://richluv.fra1.zeabur.app/">Clemenza</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/04/Matlab%E5%9F%BA%E4%BA%8ESIFT%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8B%BC%E6%8E%A5%E7%AE%97%E6%B3%95/">http://example.com/2024/11/04/Matlab%E5%9F%BA%E4%BA%8ESIFT%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8B%BC%E6%8E%A5%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">此文章版权归Clemenza所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a></div><div class="post-share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>欢迎打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE.jpg" target="_blank"><img class="post-qr-code-img" src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE.jpg" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE.jpg" target="_blank"><img class="post-qr-code-img" src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE.jpg" alt="支付宝支付"/></a><div class="post-qr-code-desc">支付宝支付</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/11/Human-in-the-loop%20optimization%20of%20exoskeleton%20assistance%20during%20walking/" title="Human-in-the-loop optimization of exoskeleton assistance during walking"><img class="cover" src="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Human-in-the-loop optimization of exoskeleton assistance during walking</div></div><div class="info-2"><div class="info-item-1">对实验室张老师一篇发布在Science上的文章解读</div></div></div></a><a class="pagination-related" href="/2024/11/04/Opensim%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="OpenSim基础教程"><img class="cover" src="https://picx.zhimg.com/80/v2-d133dd131c085d7dcd530e7d2b01c752_720w.webp?source=d16d100b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">OpenSim基础教程</div></div><div class="info-2"><div class="info-item-1">OpenSim的一些基础教程，包括下载、安装、和基础操作等</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/04/Opensim%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="OpenSim基础教程"><img class="cover" src="https://picx.zhimg.com/80/v2-d133dd131c085d7dcd530e7d2b01c752_720w.webp?source=d16d100b" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="info-item-2">OpenSim基础教程</div></div><div class="info-2"><div class="info-item-1">OpenSim的一些基础教程，包括下载、安装、和基础操作等</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Clemenza</div><div class="author-info-description">Rich&Love</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Clemenza-2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Clemenza-2001" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wangyuehao2001@163.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/clemenza2001" target="_blank" title="微信"><i class="fa-solid fa-user-secret"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来到RichLuv Studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIFT%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-text">SIFT算法简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIFT%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">SIFT算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIFT%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">SIFT代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5%E7%BB%93%E6%9E%9C"><span class="toc-text">图像拼接结果</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/11/Human-in-the-loop%20optimization%20of%20exoskeleton%20assistance%20during%20walking/" title="Human-in-the-loop optimization of exoskeleton assistance during walking"><img src="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Human-in-the-loop optimization of exoskeleton assistance during walking"/></a><div class="content"><a class="title" href="/2024/11/11/Human-in-the-loop%20optimization%20of%20exoskeleton%20assistance%20during%20walking/" title="Human-in-the-loop optimization of exoskeleton assistance during walking">Human-in-the-loop optimization of exoskeleton assistance during walking</a><time datetime="2024-11-11T11:12:02.221Z" title="Created 2024-11-11 19:12:02">2024-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/04/Matlab%E5%9F%BA%E4%BA%8ESIFT%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8B%BC%E6%8E%A5%E7%AE%97%E6%B3%95/" title="Matlab基于SIFT的图像特征匹配与拼接算法"><img src="https://pic1.zhimg.com/v2-00204a5368c2246ef3604c266a6546f6_1440w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Matlab基于SIFT的图像特征匹配与拼接算法"/></a><div class="content"><a class="title" href="/2024/11/04/Matlab%E5%9F%BA%E4%BA%8ESIFT%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8B%BC%E6%8E%A5%E7%AE%97%E6%B3%95/" title="Matlab基于SIFT的图像特征匹配与拼接算法">Matlab基于SIFT的图像特征匹配与拼接算法</a><time datetime="2024-11-04T11:53:10.481Z" title="Created 2024-11-04 19:53:10">2024-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/04/Opensim%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="OpenSim基础教程"><img src="https://picx.zhimg.com/80/v2-d133dd131c085d7dcd530e7d2b01c752_720w.webp?source=d16d100b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenSim基础教程"/></a><div class="content"><a class="title" href="/2024/11/04/Opensim%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="OpenSim基础教程">OpenSim基础教程</a><time datetime="2024-11-04T08:20:33.690Z" title="Created 2024-11-04 16:20:33">2024-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/29/hello-world/" title="自我介绍"><img src="/img/sza.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自我介绍"/></a><div class="content"><a class="title" href="/2024/10/29/hello-world/" title="自我介绍">自我介绍</a><time datetime="2024-10-29T03:10:33.803Z" title="Created 2024-10-29 11:10:33">2024-10-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2024 By Clemenza</div><div class="footer_custom_text">不积硅步，无以至千里</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>